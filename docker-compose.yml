# docker-compose build, docker-compose run

# создание самого джанго приложения в папке WORKDIR /service
# docker-compose run --rm sh -c "django-admin startproject service ."
# --rm — после выполнения команды контейнер будет удалён (чтобы не оставался "мусор")

services:
  # web-app: — это имя сервиса. Оно произвольное и обозначает один контейнер
  # (или группу одинаковых контейнеров), который будет запущен в составе твоего проекта
  web-app:
    build:
      # context — это путь к директории, который будет использоваться Docker для поиска всех необходимых файлов, таких
      # как Dockerfile, исходный код приложения, зависимости и любые другие файлы, которые могут понадобиться в процессе сборки контейнера
      # Если в контексте сборки будет много ненужных файлов (например, .git или другие большие папки), можно
      # использовать файл .dockerignore, чтобы исключить ненужные файлы из контекста сборки.
      context: .
    ports:
      # Первое число — это порт на хост-машине ( на компьютере или сервере), через который ты будешь взаимодействовать
      # с контейнером. Второе число (8000) — это порт внутри контейнера, на котором приложение  будет слушать запросы.
      - "8000:8000"
    volumes:
      # монтирование тома между хостом и контейнером позволяет синхронизировать файлы между хостом и контейнером во время его работы
      # подключаем локальную папку к контейнеру
      - ./service:/service
    # sh -c: Это команда для запуска шелл-скрипта. sh — это командный интерпретатор (shell), а -c — параметр, который
    # позволяет передать строку команд для выполнения. То есть, здесь мы передаем команду для выполнения, как строку.
    # 0.0.0.0 — это привязка сервера ко всем доступным сетевым интерфейсам, что позволяет подключаться к
    # серверу не только изнутри контейнера, но и извне.
    command: >
      sh -c "python manage.py runserver 0.0.0.0:8000"
